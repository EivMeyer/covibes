<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Code Terminal - Working Implementation</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #1e1e1e;
      color: #d4d4d4;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #header {
      background: #252526;
      padding: 15px;
      border-bottom: 1px solid #3e3e42;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #status {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #666;
    }
    .status-indicator.connected {
      background: #0dbc79;
      box-shadow: 0 0 5px #0dbc79;
    }
    .status-indicator.error {
      background: #cd3131;
      box-shadow: 0 0 5px #cd3131;
    }
    #terminal-container {
      flex: 1;
      padding: 10px;
      overflow: hidden;
    }
    #terminal {
      width: 100%;
      height: 100%;
    }
    button {
      background: #0e639c;
      color: #fff;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
      border-radius: 4px;
      transition: all 0.2s;
    }
    button:hover:not(:disabled) {
      background: #1177bb;
    }
    button:disabled {
      background: #3e3e42;
      cursor: not-allowed;
      opacity: 0.6;
    }
    h1 {
      font-size: 18px;
      font-weight: normal;
      color: #cccccc;
    }
    .agent-id {
      color: #3b8eea;
      font-family: monospace;
      font-size: 13px;
    }
    /* Remove xterm focus outline */
    .xterm .xterm-screen {
      outline: none !important;
    }
    .xterm:focus .xterm-screen {
      outline: none !important;
    }
    .xterm-screen:focus {
      outline: none !important;
    }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <h1>Claude Code Terminal</h1>
      <div class="agent-id" id="agent-info">Initializing...</div>
    </div>
    <div id="status">
      <div class="status-item">
        <span>Socket:</span>
        <div id="socket-status" class="status-indicator"></div>
        <span id="socket-text">Disconnected</span>
      </div>
      <div class="status-item">
        <span>Agent:</span>
        <div id="agent-status" class="status-indicator"></div>
        <span id="agent-text">Not spawned</span>
      </div>
      <button id="spawn-btn" disabled>Spawn Agent</button>
      <button id="reconnect-btn" style="display: none;">Reconnect</button>
    </div>
  </div>

  <div id="terminal-container">
    <div id="terminal"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-webgl@0.16.0/lib/xterm-addon-webgl.js"></script>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    // Configuration
    const BACKEND_URL = window.location.origin;
    const DEMO_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJjbTBrbGZlMWQwMDAwMTNwMGc0OWE1MzJnIiwidGVhbUlkIjoiZGVtby10ZWFtLTAwMSIsInVzZXJOYW1lIjoiVGVzdCBVc2VyIiwiZW1haWwiOiJ0ZXN0QGV4YW1wbGUuY29tIiwiaWF0IjoxNzI1ODk5OTY0LCJleHAiOjE3NTc0MzU5NjR9.l6Gks7egUqg7Bod59r3gnjLBiAzFCQjtFvNzcrXPNt8';

    // State
    let socket = null;
    let terminal = null;
    let fitAddon = null;
    let webglAddon = null;
    let currentAgentId = null;
    let isConnected = false;
    let isSpawning = false;

    // UI Updates
    function updateSocketStatus(connected) {
      const indicator = document.getElementById('socket-status');
      const text = document.getElementById('socket-text');
      const spawnBtn = document.getElementById('spawn-btn');
      const reconnectBtn = document.getElementById('reconnect-btn');

      if (connected) {
        indicator.className = 'status-indicator connected';
        text.textContent = 'Connected';
        spawnBtn.disabled = false;
        reconnectBtn.style.display = 'none';
      } else {
        indicator.className = 'status-indicator error';
        text.textContent = 'Disconnected';
        spawnBtn.disabled = true;
        if (!isConnected) {
          reconnectBtn.style.display = 'inline-block';
        }
      }
    }

    function updateAgentStatus(status, agentId = null) {
      const indicator = document.getElementById('agent-status');
      const text = document.getElementById('agent-text');
      const info = document.getElementById('agent-info');
      const btn = document.getElementById('spawn-btn');

      switch(status) {
        case 'spawning':
          indicator.className = 'status-indicator';
          text.textContent = 'Spawning...';
          info.textContent = 'Spawning agent...';
          btn.disabled = true;
          break;
        case 'connected':
          indicator.className = 'status-indicator connected';
          text.textContent = 'Connected';
          info.textContent = `Agent ID: ${agentId}`;
          btn.disabled = true;
          btn.textContent = 'Agent Running';
          break;
        case 'error':
          indicator.className = 'status-indicator error';
          text.textContent = 'Error';
          info.textContent = 'Failed to spawn agent';
          btn.disabled = !isConnected;
          btn.textContent = 'Retry Spawn';
          break;
        default:
          indicator.className = 'status-indicator';
          text.textContent = 'Not spawned';
          info.textContent = 'Ready to spawn agent';
          btn.disabled = !isConnected;
          btn.textContent = 'Spawn Agent';
      }
    }

    // Terminal initialization
    function initTerminal() {
      console.log('Initializing terminal...');

      terminal = new Terminal({
        cursorBlink: true,
        fontSize: 14,
        fontFamily: 'Menlo, Monaco, "Courier New", monospace',
        allowProposedApi: true,
        convertEol: true,
        scrollback: 10000,
        tabStopWidth: 4,
        theme: {
          background: '#1e1e1e',
          foreground: '#d4d4d4',
          cursor: '#ffffff',
          cursorAccent: '#1e1e1e',
          selection: '#264f78',
          selectionForeground: '#ffffff',

          // ANSI colors
          black: '#000000',
          red: '#cd3131',
          green: '#0dbc79',
          yellow: '#e5e510',
          blue: '#2472c8',
          magenta: '#bc3fbc',
          cyan: '#11a8cd',
          white: '#e5e5e5',

          // Bright ANSI colors
          brightBlack: '#666666',
          brightRed: '#f14c4c',
          brightGreen: '#23d18b',
          brightYellow: '#f5f543',
          brightBlue: '#3b8eea',
          brightMagenta: '#d670d6',
          brightCyan: '#29b8db',
          brightWhite: '#ffffff'
        }
      });

      fitAddon = new FitAddon.FitAddon();
      terminal.loadAddon(fitAddon);

      // Try to load WebGL addon for better performance
      try {
        webglAddon = new WebglAddon.WebglAddon();
        webglAddon.onContextLoss(() => {
          webglAddon.dispose();
        });
        terminal.loadAddon(webglAddon);
      } catch (e) {
        console.log('WebGL addon not supported, using canvas renderer');
      }

      terminal.open(document.getElementById('terminal'));

      // Initial fit
      setTimeout(() => {
        fitAddon.fit();
      }, 50);

      // Handle terminal input - send to agent via WebSocket
      terminal.onData((data) => {
        if (currentAgentId && socket && socket.connected) {
          console.log('Sending terminal input:', data);
          socket.emit('terminal_input', {
            agentId: currentAgentId,
            data: data
          });
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (fitAddon) {
          fitAddon.fit();
          if (currentAgentId && socket && socket.connected) {
            socket.emit('terminal_resize', {
              agentId: currentAgentId,
              cols: terminal.cols,
              rows: terminal.rows
            });
          }
        }
      });

      // Add resize observer for more responsive resizing
      const resizeObserver = new ResizeObserver(() => {
        if (fitAddon) {
          setTimeout(() => {
            fitAddon.fit();
            if (currentAgentId && socket && socket.connected) {
              socket.emit('terminal_resize', {
                agentId: currentAgentId,
                cols: terminal.cols,
                rows: terminal.rows
              });
            }
          }, 50);
        }
      });

      const terminalContainer = document.getElementById('terminal-container');
      if (terminalContainer) {
        resizeObserver.observe(terminalContainer);
      }

      terminal.writeln('Terminal initialized. Connecting to server...');
      console.log('Terminal initialization complete');
    }

    // Socket connection
    function connectSocket() {
      console.log('Connecting to socket server...');

      socket = io(BACKEND_URL, {
        auth: { token: DEMO_TOKEN },
        transports: ['websocket'],
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionAttempts: 5
      });

      socket.on('connect', () => {
        console.log('Socket connected');
        isConnected = true;
        updateSocketStatus(true);
        terminal.writeln('\x1b[32m✓ Connected to server\x1b[0m');

        // Auto-spawn agent on first connect
        if (!currentAgentId && !isSpawning) {
          setTimeout(spawnAgent, 500);
        }
      });

      socket.on('disconnect', () => {
        console.log('Socket disconnected');
        isConnected = false;
        updateSocketStatus(false);
        terminal.writeln('\x1b[31m✗ Disconnected from server\x1b[0m');
      });

      socket.on('error', (error) => {
        console.error('Socket error:', error);
        terminal.writeln(`\x1b[31mSocket error: ${error}\x1b[0m`);
      });

      // Terminal events
      socket.on('terminal_connected', (data) => {
        console.log('Terminal connected event:', data);
        terminal.writeln('\x1b[32m✓ Terminal connected\x1b[0m');
        terminal.writeln('');
        updateAgentStatus('connected', currentAgentId);

        // Request initial terminal buffer
        socket.emit('request_terminal_buffer', {
          agentId: currentAgentId
        });
      });

      socket.on('terminal_data', (data) => {
        console.log('Received terminal_data:', data);
        if (data && data.agentId === currentAgentId && data.data) {
          // Write the raw terminal data directly
          terminal.write(data.data);
        }
      });

      socket.on('terminal_buffer', (data) => {
        console.log('Received terminal buffer:', data);
        if (data && data.agentId === currentAgentId && data.buffer) {
          terminal.write(data.buffer);
        }
      });

      socket.on('terminal_error', (data) => {
        console.error('Terminal error:', data);
        terminal.writeln(`\x1b[31mTerminal error: ${data.error}\x1b[0m`);
      });

      socket.on('agent_spawned', (data) => {
        console.log('Agent spawned event:', data);
      });

      socket.on('agent_output', (data) => {
        console.log('Agent output event:', data);
        if (data && data.agentId === currentAgentId && data.data) {
          terminal.write(data.data);
        }
      });

      socket.on('pty-data', (data) => {
        console.log('PTY data event:', data);
        if (data && data.agentId === currentAgentId && data.data) {
          terminal.write(data.data);
        }
      });
    }

    // Spawn agent
    async function spawnAgent() {
      if (!isConnected || isSpawning || currentAgentId) {
        console.log('Cannot spawn: connected=' + isConnected + ', spawning=' + isSpawning + ', hasAgent=' + !!currentAgentId);
        return;
      }

      isSpawning = true;
      updateAgentStatus('spawning');
      terminal.writeln('\x1b[33mSpawning Claude Code agent...\x1b[0m');

      try {
        // Join team first and wait for acknowledgment
        await new Promise((resolve, reject) => {
          console.log('Joining team demo-team-001...');

          socket.emit('join-team', {
            teamId: 'demo-team-001',
            token: DEMO_TOKEN
          }, (response) => {
            // Handle acknowledgment if server sends one
            console.log('Join-team acknowledged:', response);
            resolve(response);
          });

          // Timeout fallback
          setTimeout(resolve, 500);
        });

        console.log('Team joined, proceeding with agent spawn...');

        // Spawn agent via API
        const response = await fetch(`${BACKEND_URL}/api/agents/spawn`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${DEMO_TOKEN}`
          },
          body: JSON.stringify({
            task: 'Interactive terminal session',
            teamId: 'demo-team-001'
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        currentAgentId = data.id || data.agentId || data.agent?.id;

        if (!currentAgentId) {
          throw new Error('No agent ID in response');
        }

        console.log('Agent spawned:', currentAgentId);
        terminal.writeln(`\x1b[32m✓ Agent spawned: ${currentAgentId}\x1b[0m`);
        terminal.writeln('\x1b[33mConnecting to terminal...\x1b[0m');

        // Connect to terminal - send once after confirming connection
        setTimeout(() => {
          console.log('Sending terminal_connect for agent:', currentAgentId);

          // Send terminal_connect event
          socket.emit('terminal_connect', {
            agentId: currentAgentId
          });

          console.log('terminal_connect event sent');
        }, 1000);

        // Send initial terminal size after a delay
        setTimeout(() => {
          if (terminal && socket && socket.connected) {
            socket.emit('terminal_resize', {
              agentId: currentAgentId,
              cols: terminal.cols,
              rows: terminal.rows
            });
          }
        }, 2000);

      } catch (error) {
        console.error('Failed to spawn agent:', error);
        terminal.writeln(`\x1b[31mError: ${error.message}\x1b[0m`);
        updateAgentStatus('error');
        currentAgentId = null;
      } finally {
        isSpawning = false;
      }
    }

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      initTerminal();
      connectSocket();

      // Button handlers
      document.getElementById('spawn-btn').addEventListener('click', spawnAgent);

      document.getElementById('reconnect-btn').addEventListener('click', () => {
        location.reload();
      });
    });
  </script>
</body>
</html>